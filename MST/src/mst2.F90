program mst2
   use ISO_FORTRAN_ENV, only : compiler_version, compiler_options
!
   use KindParamModule, only : IntKind, RealKind, CmplxKind
!
   use MathParamModule, only : ZERO, TEN2m8, TEN2m6, TEN2m5, TEN2m3, ONE, PI4, THIRD
!
   use ChemElementModule, only : getZval
!
   use TimerModule, only : initTimer, endTimer, getTime, fetchStoredTime
   use TimerModule, only : registerRoutine 
!
   use ErrorHandlerModule, only : setErrorOutput, ErrorHandler, WarningHandler
!
   use MPPModule, only : initMPP, endMPP, syncAllPEs, GlobalMax
   use MPPModule, only : getMyPE, getNumPEs, getMaxWaits, setMaxWaits
!
   use GroupCommModule, only : initGroupComm, endGroupComm, getGroupID, getMyPEinGroup
!
   use ParallelIOModule, only : initParallelIO, endParallelIO
!
   use DataServiceCenterModule, only : initDataServiceCenter, &
                                       endDataServiceCenter, &
                                       getDataStorage, RealMark
!
   use PublicTypeDefinitionsModule, only : MixListStruct,  &
                                           UniformGridStruct
!
   use PublicParamDefinitionsModule, only : PrintDOSswitchOff, ButterFly
   use PublicParamDefinitionsModule, only : VertLine, MatsubaraPoles
   use PublicParamDefinitionsModule, only : StandardInputFile
!
   use InputModule, only : initInput, endInput, readInputData
   use InputModule, only : openInputFile, closeInputFile
   use InputModule, only : getKeyValue, printKeyNames, getTableIndex
!
   use XMLDataModule, only : initXMLData, endXMLData
!
   use OutputModule, only : initOutput, endOutput,  &
                            isStandardOutToScreen,  &
                            getDensityPrintFlag,    &
                            getPotentialPrintFlag,  &
                            getStandardOutputLevel, isOutputAtomBased
!
!  ===================================================================
!  initPolyhedra and endPolyhedra are called in SystemModule
!  ===================================================================
!  use PolyhedraModule, only : initPolyhedra, endPolyhedra
!  use PolyhedraModule, only : genPolyhedron
   use PolyhedraModule, only : getInscrSphRadius, getOutscrSphRadius
   use PolyhedraModule, only : getWignerSeitzRadius
   use PolyhedraModule, only : getNeighborDistance
   use PolyhedraModule, only : getPointLocationFlag
   use PolyhedraModule, only : printPolyhedron
   use PolyhedraModule, only : printPolyhedronBoundary
!
   use StepFunctionModule, only : initStepFunction, endStepFunction
   use StepFunctionModule, only : printStepFunction, testStepFunction
!
   use PotentialModule, only : initPotential, endPotential
   use PotentialModule, only : readPotential, writePotential
   use PotentialModule, only : getPotEf, setV0, printPot_L
   use PotentialModule, only : setPotential, setPotEf
   use PotentialModule, only : isSphericalInputFile
!
   use TestPotentialModule, only : initTestPotential,  &
                                   endTestPotential,   &
                                   readTestPotential,  &
                                   getTestPotential,   &
                                   getTestPotEf,       &
                                   getTestV0,          &
                                   getTestValenceNum
!
   use CheckPointModule, only : initCheckPoint, endCheckPoint
!
   use ScfDataModule, only : ngaussr, ngaussq
   use ScfDataModule, only : initScfData, nscf, printScfData, potwrite, movie
   use ScfDataModule, only : n_spin_pola, n_spin_cant
   use ScfDataModule, only : ntstep, tstep
   use ScfDataModule, only : istop, iterateEf
   use ScfDataModule, only : SingleSiteEContour, RealAxisSS
   use ScfDataModule, only : inputpath, Temperature
   use ScfDataModule, only : isNonRelativisticCore
   use ScfDataModule, only : isRelativisticValence
   use ScfDataModule, only : EvBottom, ErTop, ErBottom, EiTop, EiBottom
   use ScfDataModule, only : NumEs, ContourType, eGridType
   use ScfDataModule, only : isReadEmesh, getEmeshFileName
   use ScfDataModule, only : isReadKmesh, getKmeshFileName
   use ScfDataModule, only : NumKMeshs, kGenScheme, Kdiv, Symmetrize
   use ScfDataModule, only : isScreenKKR, isKKRCPA, isKKRCPASRO, isLSMS, isScreenKKR_LSMS, &
                             isKKR, isEmbeddedCluster, isSingleSite, setScfMethod
   use ScfDataModule, only : isExchangeParamNeeded
   use ScfDataModule, only : getPotentialTypeParam
   use ScfDataModule, only : isChargeMixing, isPotentialMixing
   use ScfDataModule, only : excorr_name, rmstol
   use ScfDataModule, only : isLdaCorrectionNeeded, getUJfile
   use ScfDataModule, only : getSingleSiteSolverType, getDOSrunID
   use ScfDataModule, only : NumSS_IntEs, isSSIrregularSolOn
   use ScfDataModule, only : isFrozenCore, CurrentScfIteration
   use ScfDataModule, only : isDMFTenabled
!
   use PotentialTypeModule, only : initPotentialType, endPotentialType,      &
                                   isASAPotential, isMuffinTinPotential,     &
                                   isMuffinTinASAPotential, isTestPotential, &
                                   isMuffinTinTestPotential, isFullPotential,&
                                   printPotentialType, isSphericalPotential, &
                                   isMuffinTinFullPotential, setIsSphericalPotential
!
   use SystemModule, only : initSystem, endSystem
   use Systemmodule, only : printSystem, getBravaisLattice, getLatticeConstant
   use SystemModule, only : getNumAtoms, getAtomPosition, getAtomicNumber,   &
                            getNumVacancies
   use SystemModule, only : getUniformGridParam
   use SystemModule, only : getSystemID, getNumAtomTypes
   use SystemModule, only : updateSystem
   use SystemModule, only : writeMomentDirectionData, writeAtomPositionData
   use SystemModule, only : writeMomentMovie, writeAtomPositionMovie
   use SystemModule, only : updateSystemMovie, resetSystemMovie
   use SystemModule, only : getLmaxKKR, getLmaxRho, getLmaxPot, getLmaxPhi
!
   use MediumHostModule, only : initMediumHost, endMediumHost, printMediumHost
!
   use LatticeModule, only : initLattice, endLattice, getLatticeType
!
   use ContourModule, only : initContour, endContour, getNumEs
!
   use ProcMappingModule, only : initProcMapping, endProcMapping,            &
                                 createParallelization, getNumEsOnMyProc,    &
                                 getNumKsOnMyProc, getNumRedundantEsOnMyProc,&
                                 getNumRedundantKsOnMyProc, distributeX
!
   use SystemVolumeModule, only : initSystemVolume, endSystemVolume,         &
                                  printSystemVolume, updateSystemVolume,     &
                                  setSystemVolumeMT, getAtomicVPVolume
!
   use SystemSymmetryModule, only : initSystemSymmetry, endSystemSymmetry,&
                                    calSymmetryFlags ! ,getSymmetryFlags
!
!  ===================================================================
!  initAtom2Proc and endAtom2Proc are called in main now!!!
!  ===================================================================
   use Atom2ProcModule, only : initAtom2Proc, endAtom2Proc
   use Atom2ProcModule, only : getGlobalIndex, getAtom2ProcInGroup
   use Atom2ProcModule, only : printAtom2ProcTable, getLocalNumAtoms
!
   use AtomModule, only : initAtom, endAtom
   use AtomModule, only : getMaxLmax, printAtom, getStepFuncLmax
   use AtomModule, only : getPotLmax, getKKRLmax, getPhiLmax, getRhoLmax
   use AtomModule, only : getTruncPotLmax
   use AtomModule, only : getRadialGridData, getMuffinTinRadius, setMuffinTinRadius
   use AtomModule, only : getLocalAtomName, getLocalAtomicNumber
   use AtomModule, only : getLocalNumSpecies, getLocalSpeciesContent
   use AtomModule, only : printAtomMomentInfo
!   use AtomModule, only : setAtomVolMT, setAtomVolVP
!   use AtomModule, only : setAtomVolWS, setAtomVolINSC
   use AtomModule, only : getLocalAtomPosition, getLocalEvec
   use AtomModule, only : getAtomCoreRad, setAtomCoreRad
   use AtomModule, only : getLocalConstrainField, updateLocalExchangeFieldDir
   use AtomModule, only : getMixingParam4Evec ! , resetCompFlags, getCompFlags
!
   use SphericalHarmonicsModule, only : initSphericalHarmonics
   use SphericalHarmonicsModule, only : endSphericalHarmonics
!
   use GauntFactorsModule, only : initGauntFactors, endGauntFactors
!
   use NeighborModule, only : initNeighbor, endNeighbor
   use SendRecvTmatModule, only : initSendRecvTmat, endSendRecvTmat, getNumProcWiseSends
!
   use RadialGridModule, only : initRadialGrid, endRadialGrid
   use RadialGridModule, only : genRadialGrid, printRadialGrid
   use RadialGridModule, only : getRadialGridRadius
!
   use CoreStatesModule, only : initCoreStates, calCoreStates, endCoreStates
   use CoreStatesModule, only : readCoreStates, readCoreDensity, writeCoreDensity
   use CoreStatesModule, only : printCoreStates, printCoreDensity
!
   use BZoneModule, only : initBZone, printBZone, endBZone, getNumRotations, &
                           getNumKs
!
   use IBZRotationModule, only : initIBZRotation, endIBZRotation, computeRotationMatrix, &
                                 printIBZRotationMatrix, checkCrystalSymmetry
!
   use SpinRotationModule, only :  initSpinRotation, endSpinRotation
!
   use ValenceDensityModule, only : initValenceDensity, getFermiEnergy, endValenceDensity
   use ValenceDensityModule, only : setValenceVPCharge, setValenceVPMomentSize
   use ValenceDensityModule, only : getExchangeEnergy
!
   use GFMethodModule, only : initGFMethod, printValenceStates, &
                              endGFMethod
   use GFMethodModule, only : calValenceStates, calValenceDOS, writeSS_DOS, writeDOS, calPartialDOS
   use GFMethodModule, only : printExchangeParam
!
   use Uniform3DGridModule, only : initUniform3DGrid, endUniform3DGrid
   use Uniform3DGridModule, only : isUniform3DGridInitialized, createUniform3DGrid, printUniform3DGrid
   use Uniform3DGridModule, only : createProcessorMesh, insertAtomsInGrid, getUniform3DGrid
   use Uniform3DGridModule, only : distributeUniformGrid
!
   use IsoparametricIntegrationModule, only : initIsoparametricIntegration, &
                                              endIsoparametricIntegration
!
   use MadelungModule, only : initMadelung, endMadelung, printMadelungMatrix
!
   use ChargeDistributionModule, only : initChargeDistribution,     &
                                        endChargeDistribution,      &
                                        updateChargeDistribution
!
   use PotentialGenerationModule, only : initPotentialGeneration,  &
                                         endPotentialGeneration,   &
                                         computeNewPotential
!
   use TotalEnergyModule, only : initTotalEnergy, endTotalEnergy,     &
                                 computeEnergyFunctional, printTotalEnergy, &
                                 getEnergyPerAtom, getPressurePerAtom
!
   use MixingModule, only : initMixing, endMixing, mixValues
!
   use ExchCorrFunctionalModule, only : initExchCorrFunctional,   &
                                        endExchCorrFunctional,    &
                                        isLDAFunctional,          &
                                        isGGAFunctional,          &
                                        isMGGAFunctional,         &
                                        isHybridFunctional,       &
                                        isHartreeApproximation
!
   use ConvergenceCheckModule, only : initConvergenceCheck, &
                                      endConvergenceCheck,  &
                                      checkConvergence
!
   use ConstrainLocalMomentModule, only : initConstrainLM,            &
                                          endConstrainLM,             &
                                          printConstrainMoment,       &
                                          calConstrainLM,             &
                                          updateConstrainLM
!
   use BookKeepingModule, only : initBookKeeping, endBookKeeping
!
!v2.0  use ExchangeInteractionModule, only : initExchangeInteraction, &
!v2.0                   endExchangeInteraction, calExchgInteractions, &
!v2.0                   printExchange
!
   use ChargeDensityModule, only : initChargeDensity,         &
                                   endChargeDensity,          &
                                   constructChargeDensity,    &
                                   isChargeComponentZero,     &
                                   updateTotalDensity
!
   use LdaCorrectionModule, only : initLdaCorrection, endLdaCorrection, &
                                   insertCorrectionOrbitals, getTransformMatrix, &
                                   checkLdaCorrection
!
   use SurfElementsModule, only : printSurfaceElements
!
   use ForceModule, only : initForce, endForce, calForce, printForce, writeForceData
!
   use KreinModule, only : initKrein, endKrein
!
   use CmdLineOptionModule, only : getCmdLineOptionValue
!
   implicit none
!
   logical :: ScfConverged = .false.
   logical :: FileNamed = .false.
   logical :: isRmtUpdated = .false.
   logical :: IsoParamVINT = .false.
   logical :: FrozenCoreFileExist = .false.
   logical :: StandardInputExist = .false.
   logical :: isDOSCalculationOnly = .false.
   logical :: Symmetrize_mod = .false.
!
   character (len=80) :: info_table, info_path
   character (len=160) :: itname, cmd
   character (len=12) :: anm
   character (len=8)  :: code_version
   character (len=8)  :: exec_date
   character (len=10) :: exec_time
   character (len=200) :: FileName
   character (len=50) :: StorageKey
   character (len=50) :: FrozenCoreFileName = 'FrozenCoreDensity.dat'
!
   integer (kind=IntKind) :: MyPE, NumPEs
   integer (kind=IntKind) :: NumWriteProcs, NumReadProcs
   integer (kind=IntKind) :: funit_sysmov, en_movie
   integer (kind=IntKind) :: def_id, info_id
   integer (kind=IntKind) :: i, id, ig, is, jl, nk, ne, n, na, ia
   integer (kind=IntKind) :: iscf, itstep, niter, sdstep_new
   integer (kind=IntKind) :: n_write, n_potwrite
   integer (kind=IntKind) :: lmax_max, lmax_kkr_max, GlobalNumAtoms, jmax_pot
   integer (kind=IntKind) :: lmax_rho_max, lmax_pot_max, lmax_gaunt
   integer (kind=IntKind) :: ndivin, ndivout, nmult
   integer (kind=IntKind) :: NumRotations
   integer (kind=IntKind) :: LocalNumAtoms
   integer (kind=IntKind) :: node_print_level
   integer (kind=IntKind) :: rstatus, calTc
   integer (kind=IntKind), pointer :: AtomicNumber(:)
   integer (kind=IntKind), allocatable :: atom_print_level(:)
   integer (kind=IntKind), allocatable :: GlobalIndex(:)
   integer (kind=IntKind), allocatable :: lmax_tmp(:)
   integer (kind=IntKind), allocatable :: lmax_pot(:)
   integer (kind=IntKind), allocatable :: lmax_kkr(:)
   integer (kind=IntKind), allocatable :: lmax_phi(:)
   integer (kind=IntKind), allocatable :: lmax_rho(:)
   integer (kind=IntKind), allocatable :: lmax_step(:)
   integer (kind=IntKind), allocatable :: lmax_green(:)
   integer (kind=IntKind), allocatable :: lmax_mad(:)
   integer (kind=IntKind), allocatable :: ngr(:), ngt(:)
   integer (kind=IntKind) :: NumMix(1)
   integer (kind=IntKind) :: MaxVal_Integer(2)
!  Needed for L-SIC:
   integer (kind=IntKind) :: lsic_mode
   integer (kind=IntKind) :: vna, vnb, vnc
!
   real (kind=RealKind), pointer :: AtomPosition(:,:)
   real (kind=RealKind), allocatable :: LocalNumValenceElectrons(:)
   real (kind=RealKind), allocatable :: LocalAtomPosi(:,:)
   real (kind=RealKind), allocatable :: LocalEvec(:,:)
   real (kind=RealKind), allocatable :: radius(:)
!
   real (kind=RealKind), allocatable :: rho_rms(:,:), pot_rms(:,:)
   real (kind=RealKind), allocatable :: evec_rms(:), bcon_rms(:)
   real (kind=RealKind), allocatable :: bcon_sd(:,:)
   real (kind=RealKind) :: max_rms(8), keep_rms(4)
!
   real (kind=RealKind) :: vcell(3,3), vorigin(3)
   real (kind=RealKind) :: bravais(3,3)
   real (kind=RealKind) :: alat
   real (kind=RealKind) :: rmt, rinsc, rend, rws, hin, rmt_grid, rc
   real (kind=RealKind) :: Efermi, volume, cfac
   real (kind=RealKind) :: v0, val, evb
   real (kind=RealKind) :: t0, t1, t2, t3, t_inp, t_outp
   real (kind=RealKind) :: t_mpi_init, t_mpi_group, t_read_input
!
   real (kind=RealKind), pointer :: mom_table(:)
!
   real (kind=RealKind), parameter :: xstart = -.1113096740000D+02
!  real (kind=RealKind), parameter :: xstart = -.913096740000D+01
!
   complex (kind=CmplxKind), pointer :: pot_l(:)
!
!  ===================================================================
!  Mixing quantity
!  ===================================================================
   type (MixListStruct), target :: ArrayList
!
!  type (UniformGridStruct), pointer:: fftgp
!
   interface
!
!      subroutine setupLizNeighbor(print_level,isScreened)
      subroutine setupLizNeighbor(print_level)
         use KindParamModule, only : IntKind
         integer (kind=IntKind), intent(in) :: print_level(*)
!         logical, optional,intent(in)       :: isScreened
      end subroutine setupLizNeighbor
!
      subroutine setupMixRealArrayList(NLA, nsp, RAList, r_rms, p_rms)
         use KindParamModule, only : IntKind, RealKind
         use PublicTypeDefinitionsModule, only : MixListStruct
         implicit none
         integer (kind=IntKind), intent(in) :: NLA,nsp
         real (kind=RealKind), intent(in) :: r_rms(:,:)
         real (kind=RealKind), intent(in) :: p_rms(:,:)
         type (MixListStruct), target :: RAList
      end subroutine setupMixRealArrayList
!
      subroutine setupMixCmplxArrayList(NLA, nsp, CAList, r_rms, p_rms)
         use KindParamModule, only : IntKind, RealKind
         use PublicTypeDefinitionsModule, only : MixListStruct
         implicit none
         integer (kind=IntKind), intent(in) :: NLA,nsp
         real (kind=RealKind), intent(in) :: r_rms(:,:)
         real (kind=RealKind), intent(in) :: p_rms(:,:)
         type (MixListStruct), target :: CAList
      end subroutine setupMixCmplxArrayList
!
      subroutine updateMixRealValues( NLA, nsp, RAList )
         use KindParamModule, only : IntKind, RealKind
         use PublicTypeDefinitionsModule, only : MixListStruct
         implicit none
         integer (kind=IntKind), intent(in) :: NLA,nsp
         type (MixListStruct), target :: RAList
      end subroutine updateMixRealValues
!
      subroutine updateMixCmplxValues( NLA, nsp, CAList)
         use KindParamModule, only : IntKind, RealKind
         use PublicTypeDefinitionsModule, only : MixListStruct
         implicit none
         integer (kind=IntKind), intent(in) :: NLA,nsp
         type (MixListStruct), target :: CAList
      end subroutine updateMixCmplxValues
!
      function getValBandEnergy(na,ia,is) result(be)
         use KindParamModule, only : IntKind, RealKind
         integer (kind=IntKind), intent(in) :: na, ia, is
         real (kind=RealKind) :: be
      end function getValBandEnergy
!
      function getSphValDensity(na,ia,is) result(rho)
         use KindParamModule, only : IntKind, RealKind
         integer (kind=IntKind), intent(in) :: na, ia, is
         real (kind=RealKind), pointer :: rho(:)
      end function getSphValDensity
!
      subroutine printScfResults(gna, lna, np, ap, nw, mov, i, n, c)
         use KindParamModule, only : IntKind
         logical, intent(in) :: c
         integer (kind=IntKind), intent(in) :: gna, lna, np, mov, i, n
         integer (kind=IntKind), intent(in) :: ap(lna)
         integer (kind=IntKind), intent(inout) :: nw
      end subroutine printScfResults
!
   end interface
!
!  -------------------------------------------------------------------
   call initTimer()
!  -------------------------------------------------------------------
   t0 = getTime()
   t_inp = ZERO; t_outp = ZERO
!
!  -------------------------------------------------------------------
   call initMPP()
!  -------------------------------------------------------------------
   t_mpi_init = getTime() - t0
   MyPE = getMyPE()
   NumPEs = getNumPEs()
!  -------------------------------------------------------------------
!
   call date_and_time(exec_date,exec_time)
!
   include "MuST_version"
!
   if (MyPE == 0) then
      write(6,'(13a,i5,a)')'Execution starts at ',                            &
                   exec_time(1:2),':',exec_time(3:4),':',exec_time(5:6),', ', &
                   exec_date(5:6),'-',exec_date(7:8),'-',exec_date(1:4),      &
                   ' on ',NumPEs,' nodes'
!!    write(6,'(80(''-''),/)')
!!    write(6,'(/)')
!!    write(6,'(12x,a)')'********************************************************'
!!    write(6,'(12x,a)')'*                                                      *'
!!    write(6,'(12x,a)')'*    Full-Potential Multiple Scattering Theory Based   *'
!!    write(6,'(12x,a)')'*                                                      *'
!!    write(6,'(12x,a)')'*  Ab Initio Electronic Structure Calculation Package  *'
!!    write(6,'(12x,a)')'*                                                      *'
!!    write(6,'(12x,a)')'*                    Version 2.4.x.x                   *'
!!    write(6,'(12x,a)')'*                                                      *'
!!    write(6,'(12x,a)')'********************************************************'
!!    write(6,'(/,80(''=''))')
!     ----------------------------------------------------------------
      call print_version(6)
!     ----------------------------------------------------------------
   endif
!
   t1 = getTime()
!  -------------------------------------------------------------------
   call initGroupComm()
!  -------------------------------------------------------------------
   call initCheckPoint()
!  -------------------------------------------------------------------
!
!  ===================================================================
!  call initDataServiceCenter to startup the Data Storage Service
!  -------------------------------------------------------------------
   call initDataServiceCenter()
!  -------------------------------------------------------------------
   t3 = getTime()
   t_mpi_group = t3 - t1
!
!  ===================================================================
!  call readInput to obtain input data................................
!      Proc 0: read input data file and broadcast to other processors
!      Other : wait and receive the data from Proc 0.
!  -------------------------------------------------------------------
   call initInput()
!  -------------------------------------------------------------------
!  FileName = 'None'
!  inquire(unit=5,name=FileName,named=FileNamed)
   inquire(unit=5,name=FileName,exist=StandardInputExist)
!  write(6,*) "main:: Input file open: ",trim(FileName)
!  *******************************************************************
!  if (FileNamed) then
   if (StandardInputExist) then
!     ----------------------------------------------------------------
      call readInputData(5,def_id)
!     ----------------------------------------------------------------
   else ! The standard input can be taken from a file named as StandardInputFile
!     ----------------------------------------------------------------
      call openInputFile(7,StandardInputFile)
      call readInputData(7,def_id)
!     ----------------------------------------------------------------
   endif
!
!  ===================================================================
!  Check if we are performing a self interaction corrected calculation
!  -------------------------------------------------------------------
   if (getKeyValue(def_id,'Local SIC',lsic_mode) /= 0) then
!     ----------------------------------------------------------------
      call ErrorHandler('main','Input parameter is not found!')
!     ----------------------------------------------------------------
   endif
   if(lsic_mode.ne.0) then
     write(6,*) 'Local SIC mode ',lsic_mode
     call ErrorHandler('main','L-SIC not implemented yet! Be patient ...')
   end if
!
!  ===================================================================
!  get the name and path of the system information data table file
!  -------------------------------------------------------------------
   if (getKeyValue(def_id,'Current File Path',info_path) /= 0) then
!     ----------------------------------------------------------------
      call ErrorHandler('main','Input parameter for Current File Path is not found!')
!     ----------------------------------------------------------------
   endif
!
   if (getKeyValue(def_id,'Info Table File Name',info_table) == 0) then
      itname = trim(info_path)//info_table
      info_id = getTableIndex(itname)
      if (info_id < 1) then
!        -------------------------------------------------------------
         call openInputFile(10,itname)
         call readInputData(10,info_id)
!        -------------------------------------------------------------
      endif
   else
      info_id = def_id
   endif
   t1 = getTime()
   t_read_input = t1 - t3
   t_inp = t_inp + t_read_input
!  *******************************************************************
!
!  ===================================================================
!  initialize SCF-calculation related data
!  -------------------------------------------------------------------
   call initScfData(def_id)
!  -------------------------------------------------------------------
!
!  ===================================================================
!  initialize Potential Type
!  -------------------------------------------------------------------
   call initPotentialType(getPotentialTypeParam())
!  -------------------------------------------------------------------
!
!  ===================================================================
!  initialize system (unit cell and related data)
!  ===================================================================
   call initSystem(def_id)
!  -------------------------------------------------------------------
   t_inp = t_inp + fetchStoredTime()
!
!  ===================================================================
!  Check data consistency
!  ===================================================================
   if (getLmaxKKR() /= getLmaxPhi()) then
      call WarningHandler('main',                                  &
           'Recommended setting lmax_kkr = lmax_phi in info_table file')
   else if (isFullPotential()) then
      if (getLmaxRho() /= 2*getLmaxKKR()) then
         call WarningHandler('main',                                  &
              'Recommended setting lmax_rho = 2*lmax_kkr in info_table file')
      else if (getLmaxRho() /= getLmaxPot()) then
         call WarningHandler('main',                                  &
              'Recommended setting lmax_rho = lmax_pot in info_table file')
      endif
   endif
!
!  ===================================================================
!  Determine if using Z*Tau*Z - Z*J formula for the Green function
!  ===================================================================
   if (.not.isSSIrregularSolOn() .and. NumSS_IntEs < 2) then
      call ErrorHandler('main','No. of mesh points on real energy axis < 2',NumSS_IntEs)
   endif
!
!  ===================================================================
!  Initialize the contour in energy complex plane to find the total
!  number of energy mesh needed
!  ===================================================================
   if (isReadEmesh()) then
!     ----------------------------------------------------------------
      call initContour(getEmeshFileName(), istop, -1)
!     ----------------------------------------------------------------
   else
      if (isDMFTenabled()) then
         if (ContourType /= VertLine) then
            if (MyPE == 0) then
               call WarningHandler('main','The energy contour is changed to Vertical line')
            endif
            ContourType = VertLine
         endif
         if (eGridType /= MatsubaraPoles) then
            if (MyPE == 0) then
               call WarningHandler('main','The energy grid type is changed to Matsubara poles')
            endif
            eGridType = MatsubaraPoles
         endif
         if (Temperature < TEN2m6) then
            if (MyPE == 0) then
               call WarningHandler('main','The temperature is too low and is change to 1000 Kelvin')
            endif
            Temperature = 1000
         endif
      endif
!     ----------------------------------------------------------------
      call initContour( ContourType, eGridType, NumEs, Temperature,   &
                        istop, -1, .true.)
!     ----------------------------------------------------------------
   endif
!
!  -------------------------------------------------------------------
   ne = getNumEs()
!  ne = max(NumSS_IntEs,getNumEs())
!  -------------------------------------------------------------------
!
!  ===================================================================
!  After the number of energy points is obtained, we need to call endContour
!  since initContour will be called again in GFMethod within SCF loop
!  -------------------------------------------------------------------
   call endContour()
!  -------------------------------------------------------------------
!
!  *******************************************************************
!
!  ===================================================================
   bravais(1:3,1:3)=getBravaisLattice()
!
   GlobalNumAtoms = getNumAtoms()
!
   AtomPosition => getAtomPosition()
   AtomicNumber => getAtomicNumber()
!
!  ===================================================================
!  Initialize the the lattice system
!  -------------------------------------------------------------------
   call initLattice(bravais)
!  -------------------------------------------------------------------
!
!  *******************************************************************
!
!  ===================================================================
!  Initialize the Brillouin zone mesh for k-space integration
!  ===================================================================
   if (isKKR() .or. isScreenKKR_LSMS() .or. isKKRCPA() .or. isKKRCPASRO()) then
!     ================================================================
      if (isFullPotential() .and. getLmaxKKR() >= 6 .and. Symmetrize /= 0) then
         Symmetrize = 0
         Symmetrize_mod = .true.
      endif
!     ================================================================
!
      if (isReadKmesh()) then
!        -------------------------------------------------------------
         call initBZone(getKmeshFileName(),istop,-1)
!        -------------------------------------------------------------
      else if (NumKMeshs > 0) then
!        -------------------------------------------------------------
         call initBZone(NumKMeshs,kGenScheme,Kdiv,Symmetrize,bravais, &
                        GlobalNumAtoms,AtomPosition,AtomicNumber,istop,-MyPE)
!        -------------------------------------------------------------
      else
!        -------------------------------------------------------------
         call WarningHandler('main','No K mesh is initialized')
!        -------------------------------------------------------------
      endif
      nk = getNumKs()
   else if (isFullPotential() .and. getLmaxKKR() > 2) then
      nk = (getLmaxKKR()+1)**2
   else
      nk = 1
   endif
!  ===================================================================
!
!  ===================================================================
!  Initialize the processes mapping module that determines how the
!  parallization will be performed
!  ===================================================================
   na = getNumAtoms()
!  -------------------------------------------------------------------
   call initProcMapping(na, ne, nk, isFullPotential(), istop, 0)
!  -------------------------------------------------------------------
   call createParallelization()
!  -------------------------------------------------------------------
   if (isKKR() .or. isScreenKKR_LSMS() .or. isKKRCPA() .or. isKKRCPASRO()) then
      if (NumKMeshs > 1) then
!        =============================================================
!        Distributed the denser k-mesh
!        -------------------------------------------------------------
         call distributeX('Denser K-Mesh in the IBZ',getGroupID('K-Mesh'), &
                          getNumKs(2))
!        -------------------------------------------------------------
      endif
   endif
!
!  ===================================================================
!  Note: only the 1st cluster in the group performs writing potential data
!  ===================================================================
   n = getCmdLineOptionValue('Number of Writing Processes',NumWriteProcs)
   n = getCmdLineOptionValue('Number of Reading Processes',NumReadProcs)
   if (NumWriteProcs > 0 .and. NumReadProcs > 0) then
!     ----------------------------------------------------------------
      call initParallelIO(getGroupID('Unit Cell'), 1,                 &
                          nin=NumReadProcs, nout=NumWriteProcs)
!     ----------------------------------------------------------------
   else if (NumWriteProcs > 0) then
!     ----------------------------------------------------------------
      call initParallelIO(getGroupID('Unit Cell'), 1, nout=NumWriteProcs)
!     ----------------------------------------------------------------
   else if (NumReadProcs > 0) then
!     ----------------------------------------------------------------
      call initParallelIO(getGroupID('Unit Cell'), 1, nin=NumReadProcs)
!     ----------------------------------------------------------------
   else
!     ----------------------------------------------------------------
      call initParallelIO(getGroupID('Unit Cell'), 1)
!     ----------------------------------------------------------------
   endif
!  -------------------------------------------------------------------
   call initAtom2Proc(GlobalNumAtoms)
!  -------------------------------------------------------------------
!
   LocalNumAtoms=getLocalNumAtoms()
!
!  *******************************************************************
!
!  ===================================================================
!  initialize system volume and the volume of each atom in the system
!  -------------------------------------------------------------------
   call initSystemVolume()
!  -------------------------------------------------------------------
!
!  *******************************************************************
!
!  ===================================================================
!  set up print level
!  -------------------------------------------------------------------
!  call initOutput(def_id,-MyPE)
   call initOutput(def_id)
!  -------------------------------------------------------------------
   node_print_level = getStandardOutputLevel()
   call setErrorOutput(e_print_level=1,w_print_level=node_print_level,&
                       m_print_level=node_print_level)
!  -------------------------------------------------------------------
!
   allocate(atom_print_level(1:LocalNumAtoms))
   if (isOutputAtomBased()) then
      do i=1,LocalNumAtoms
         atom_print_level(i) = getStandardOutputLevel(i)
         node_print_level = max(atom_print_level(i), node_print_level)
      enddo
   else
      do i=1,LocalNumAtoms
         atom_print_level(i) = node_print_level
      enddo
   endif
!
   if (node_print_level >= 0 .and. .not.isStandardOutToScreen()) then
!     ----------------------------------------------------------------
      call initXMLData(trim(inputpath)//'mstrun.xml',root='mst_run')
!     ----------------------------------------------------------------
      call getcwd(cmd)
!     ----------------------------------------------------------------
      write(6,'(a,a)')'Current working directory: ',trim(cmd)
!     ----------------------------------------------------------------
      call get_command(cmd)
!     ----------------------------------------------------------------
      write(6,'(a,a)')'Execution command: ',trim(cmd)
!     ----------------------------------------------------------------
      write(6,'(4a)') 'This code was compiled by ', compiler_version(), &
                      ' using the options ', compiler_options()
!     ----------------------------------------------------------------
!     n = command_argument_count()
!     ----------------------------------------------------------------
!     do i = 1, n
!        -------------------------------------------------------------
!        call get_command_argument(i,cmd)
!        -------------------------------------------------------------
!        if (len_trim(cmd) > 0) then
!           write(6,'(a,a)')'Command argument: ',trim(cmd)
!        endif
!     enddo
!     ----------------------------------------------------------------
      call get_environment_variable("HOSTNAME", cmd)
!     ----------------------------------------------------------------
      if (len(trim(cmd)) == 0) then
!        -------------------------------------------------------------
         call get_environment_variable("HOST", cmd)
!        -------------------------------------------------------------
      endif
      write(6,'(13a,i5,2a)')'Execution starts at ',                           &
                   exec_time(1:2),':',exec_time(3:4),':',exec_time(5:6),', ', &
                   exec_date(5:6),'-',exec_date(7:8),'-',exec_date(1:4),      &
                   ' on ',NumPEs,' nodes of ',trim(cmd)
!!   write(6,'(80(''-''),/)')
!!   write(6,'(/)')
!!   write(6,'(12x,a)')'********************************************************'
!!   write(6,'(12x,a)')'*                                                      *'
!!   write(6,'(12x,a)')'*    Full-Potential Multiple Scattering Theory Based   *'
!!   write(6,'(12x,a)')'*                                                      *'
!!   write(6,'(12x,a)')'*  Ab Initio Electronic Structure Calculation Package  *'
!!   write(6,'(12x,a)')'*                                                      *'
!!   write(6,'(12x,a)')'*                    Version 2.4                       *'
!!   write(6,'(12x,a)')'*                                                      *'
!!   write(6,'(12x,a)')'********************************************************'
!!   write(6,'(/)')
!    -----------------------------------------------------------------
      call print_version(6)
      call printxml_code_info(exec_date,exec_time,code_version)
!    -----------------------------------------------------------------
      write(6,'(12x,a,i5)')'Number of atoms on each processor:              ', &
                           LocalNumAtoms
      if ( isLSMS() ) then ! In this case, the k-point parallelization is used to
                           ! paralleize the single site solution for different (l,m).
         write(6,'(12x,a,i5)')'Number of L-values on each processor:           ', &
                              getNumKsOnMyProc()
         write(6,'(12x,a,i5)')'Number of redundant L-values on each processor: ', &
                              getNumRedundantKsOnMyProc()
      else
         write(6,'(12x,a,i5)')'Number of k-points on each processor:           ', &
                              getNumKsOnMyProc()
         write(6,'(12x,a,i5)')'Number of redundant k-points on each processor: ', &
                              getNumRedundantKsOnMyProc()
      endif
      write(6,'(12x,a,i5)')'Number of energies on each processor:           ', &
                           getNumEsOnMyProc()
      write(6,'(12x,a,i5)')'Number of redundant energies on each processor: ', &
                           getNumRedundantEsOnMyProc()
      write(6,'(/,80(''=''))')
!    -----------------------------------------------------------------
      call force_openmp()    ! use this only if necessary
      call print_threads(6)
!    -----------------------------------------------------------------
      if ( isKKR() ) then
         write(6,'(/,14x,a,/)')'::::  KKR Electronic Structure Calculation ::::'
      else if ( isLSMS() ) then
         write(6,'(/,14x,a,/)')'::::  LSMS Electronic Structure Calculation ::::'
      else if ( isScreenKKR() ) then
         write(6,'(/,14x,a,/)')'::::  Screend-KKR Electronic Structure Calculation ::::'
      else if ( isKKRCPA() ) then
         write(6,'(/,14x,a,/)')'::::  KKR-CPA Electronic Structure Calculation ::::'
      else if ( isKKRCPASRO() ) then
         write(6,'(/,14x,a,/)')'::::  KKR-CPA-SRO Electronic Structure Calculation ::::'
      else if ( isScreenKKR_LSMS() ) then
         write(6,'(/,14x,a,/)')'::::  Screened-KKR-LSMS Electronic Structure Calculation ::::'
      else if ( isEmbeddedCluster() ) then
         write(6,'(/,14x,a,/)')'::::  Embedded-LSMS Electronic Structure Calculation ::::'
      else if ( isSingleSite() ) then
         write(6,'(/,14x,a,/)')'::::  Single Site Electronic Structure Calculation ::::'
      endif
!
      if (Symmetrize_mod) then
         write(6,'(/)')
         write(6,'(3x,a)')'::::::::::::::::::::::::::  WARNING  ::::::::::::::::::::::::::::::'
         write(6,'(3x,a)')'::                                                               ::'
         write(6,'(3x,a)')':: For Full-potential KKR or KKR-CPA calculations with lmax > 5, ::'
         write(6,'(3x,a)')':: the k-space integration is forced to take place in the entire ::'
         write(6,'(3x,a)')':: first Brillouin zone (B.Z.), rather than in the irreducible   ::'
         write(6,'(3x,a)')':: B.Z., since the rotation symmetry of the single site regular  ::'
         write(6,'(3x,a)')':: solutions and the single site scattering matrices are found   ::'
         write(6,'(3x,a)')':: broken numerically that the symmetry opertation in B.Z. is no ::'
         write(6,'(3x,a)')':: longer valid.                                                 ::'
         write(6,'(3x,a)')':: This rotation symmetry broken problem will be addressed in a  ::'
         write(6,'(3x,a)')':: future code release.                                          ::'
         write(6,'(3x,a)')'::                                                               ::'
         write(6,'(3x,a)')':::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::'
         write(6,'(/)')
      endif
   endif
!
!  ===================================================================
!  call initAtom and setAtomData to setup Atom Module.................
!  -------------------------------------------------------------------
   call initAtom(info_id,istop,node_print_level)
!  -------------------------------------------------------------------
!
   if (isRelativisticValence()) then
      call registerRoutine('SingleDiracScattering')
   else
      call registerRoutine('solveSingleScattering')
   endif
!
   do i = 1,LocalNumAtoms
      rmt   = getMuffinTinRadius(i)
      rinsc = getInscrSphRadius(i)
      if (node_print_level >= 0 .and. .not.isStandardOutToScreen()) then
         write(6,'(a,2f20.13)')'rmt, rinsc = ',rmt,rinsc
      endif
      if (rmt < ONE) then
         if (abs(rmt) < TEN2m6) then
!           ==========================================================
!           The muffin-tin radius is set to be the inscribed radius.
!           ==========================================================
            rmt = rinsc
         else
!           ==========================================================
!           In this case, rmt is treated as a scaling factor for rinsc
!           The muffin-tin radius is set to be the inscribed radius
!           multiplied by the scaling factor
!           ==========================================================
            rmt = rmt*rinsc
         endif
!        -------------------------------------------------------------
         call setMuffinTinRadius(i,rmt)
!        -------------------------------------------------------------
!        if (.not.isFullPotential()) then
!           ==========================================================
!           For Muffin-tin, ASA, or Muffin-tin-ASA calculations, since
!           potential outside rmt is 0, core radius is set to rmt
         if (getAtomCoreRad(i) < TEN2m6) then
!           ----------------------------------------------------------
            call setAtomCoreRad(i,rmt)
!           ----------------------------------------------------------
         endif
      endif 
!
      if ( abs(rinsc-rmt) > TEN2m6) then
!        =============================================================
!        The muffin-tin radius is set to be other than the inscribed radius.
!        -------------------------------------------------------------
         call setSystemVolumeMT(i,rmt)
!        -------------------------------------------------------------
         isRmtUpdated = .true.
      endif
   enddo
   if ( isRmtUpdated ) then
!     ----------------------------------------------------------------
      call updateSystemVolume()
!     ----------------------------------------------------------------
   endif
!
   if (node_print_level >= 0) then
!     ----------------------------------------------------------------
      call printPotentialType()
      call printScfData()
      call printSystem()
      call printAtom()
!     ----------------------------------------------------------------
   endif
!
   if (getDOSrunID() == PrintDOSswitchOff) then
      isDOSCalculationOnly = .false.
   else
      isDOSCalculationOnly = .true.
   endif
!
!  ===================================================================
!  initialize medium system if needed
!  ===================================================================
   if (isKKRCPA() .or. isKKRCPASRO() .or. isEmbeddedCluster()) then
!     ----------------------------------------------------------------
      call initMediumHost(def_id)
!     ----------------------------------------------------------------
      call printMediumHost(0)
!     ----------------------------------------------------------------
   endif
!
!  ===================================================================
!  initialize LIZ
!  -------------------------------------------------------------------
   call initNeighbor(LocalNumAtoms,atom_print_level)
!  -------------------------------------------------------------------
   t3 = getTime()
#ifdef TIMING
   if (node_print_level >= 0) then
      write(6,'(/,a,f10.5,/)')'Time:: calling MPI_init: ',t_mpi_init
      write(6,'(/,a,f10.5,/)')'Time:: initializing MPI groups and data storing modules : ',t_mpi_group
      write(6,'(/,a,f10.5,/)')'Time:: reading input parameters (t1) : ',t_read_input
      write(6,'(/,a,f10.5,/)')'Time:: between after t1 and before calling setupLizNeighbor : ',t3-t1
      write(6,'(/,a,f10.5,/)')'Time:: from start to before calling setupLizNeighbor: ',t3-t0
   endif
#endif
!   if ( isScreenKKR_LSMS() ) then
!      call setupLizNeighbor(atom_print_level,isScreenKKR_LSMS())
!   else
      call setupLizNeighbor(atom_print_level)
!   endif
#ifdef TIMING
   if (node_print_level >= 0) then
      write(6,'(/,a,f10.5,/)')'Time:: calling setupLizNeighbor: ',getTime()-t3
   endif
#endif
!  -------------------------------------------------------------------
   if ( (isKKR() .or. isKKRCPA() .or. isKKRCPASRO()) &
          .and. node_print_level >= 0) then
!     ----------------------------------------------------------------
      call printBZone(Klimit=100)
!     ----------------------------------------------------------------
   endif
   call initSendRecvTmat(LocalNumAtoms,node_print_level)
   n = getNumProcWiseSends()
   if (n > getMaxWaits()) then
!     ----------------------------------------------------------------
      call setMaxWaits(n)
!     ----------------------------------------------------------------
   endif
!  ===================================================================
!
   allocate(LocalAtomPosi(3,LocalNumAtoms))
   allocate(GlobalIndex(LocalNumAtoms), LocalEvec(3,LocalNumAtoms))
!
   do id=1,LocalNumAtoms
      LocalAtomPosi(1:3,id)=getLocalAtomPosition(id)
      LocalEvec(1:3,id)=getLocalEvec(id,'old')
      GlobalIndex(id)=getGlobalIndex(id)
   enddo
!
!  *******************************************************************
!
!  ===================================================================
!  initialize radial grid
   allocate(radius(LocalNumAtoms))
   radius = TEN2m6
!  -------------------------------------------------------------------
   call initRadialGrid(LocalNumAtoms, istop, node_print_level)
!  -------------------------------------------------------------------
   isRmtUpdated = .false.
   do i=1,LocalNumAtoms
      ig=GlobalIndex(i)
!     ----------------------------------------------------------------
      call getRadialGridData(i,ndivin,ndivout,nmult,hin)
!     ----------------------------------------------------------------
      if (atom_print_level(i) >= 0) then
!        -------------------------------------------------------------
         call printPolyhedron(i)
!        -------------------------------------------------------------
      endif
!
      rend = max(getOutscrSphRadius(i),getAtomCoreRad(i))
      rmt = getMuffinTinRadius(i)
      if ( rmt < 0.010d0 ) then
         call ErrorHandler('main','rmt < 0.01',rmt)
      endif
!
      if (isMuffinTinPotential() .or. isMuffinTinTestPotential()) then
         rinsc = getInscrSphRadius(i)
         if (rmt - rinsc > TEN2m6) then
            call WarningHandler('main','rinsc < rmt, rmt is reset to rinsc',rinsc,rmt)
            rmt = rinsc
         endif
         rws = getWignerSeitzRadius(i)
!         volume = PI4*THIRD*(rws**3)
!         call setAtomVolWS(i,volume)
!         volume = PI4*THIRD*(rmt**3)
!         call setAtomVolMT(i,volume)
!         volume = PI4*THIRD*(rinsc**3)
!         call setAtomVolINSC(i,volume)
!         volume = getAtomicVPVolume(i)
!         call setAtomVolVP(i,volume)
!         call genRadialGrid( i, rinsc, rinsc, rws, ndivin, ndivout, nmult)
!
!
!        ========================================================
!???     Temporary fix due to inconsistent definitions of pzz/pzj
!???     between the relativistic and non-relativistic solvers
!        ========================================================
         if (getSingleSiteSolverType()==1) then
            rend=rws
         endif
!        ========================================================
!        -------------------------------------------------------------
!011820  call genRadialGrid( i, xstart, rmt, rinsc, rws, rend, ndivin)
!        -------------------------------------------------------------
      else if (isASAPotential() ) then
         rend =  getWignerSeitzRadius(i)
         rinsc = getWignerSeitzRadius(i)
         rmt = rinsc
!        if ( rmt < 0.010d0 ) then
!           rmt = rinsc
!        endif
!        ndivin = ndivin+11
         ndivin = ndivin+29
!        -------------------------------------------------------------
!        call genRadialGrid( i, rmt, rinsc, rend, ndivin = ndivin )
!        -------------------------------------------------------------
      else if ( isMuffinTinASAPotential() ) then
         rend =  getWignerSeitzRadius(i)
         rinsc = getWignerSeitzRadius(i)
!         volume = PI4*THIRD*(rend**3)
!         call setAtomVolWS(i,volume)
!         volume = PI4*THIRD*(rmt**3)
!         call setAtomVolMT(i,volume)
!         volume = PI4*THIRD*(rinsc**3)
!         call setAtomVolINSC(i,volume)
!         volume = getAtomicVPVolume(i)
!         call setAtomVolVP(i,volume)
!         call genRadialGrid( i, rmt, rinsc, rinsc, ndivin, ndivout, nmult)
!        -------------------------------------------------------------
!        call genRadialGrid( i, rmt, rinsc, rend, ndivin = ndivin )
!        -------------------------------------------------------------
      else
         if (getNeighborDistance(i,1)-getOutscrSphRadius(i) < TEN2m8) then
!           ----------------------------------------------------------
            call WarningHandler('main',                               &
                     'Ill condition found: Neighbor distance <= Rcs', &
                     getNeighborDistance(i,1),getOutscrSphRadius(i))
!           ----------------------------------------------------------
         endif
         rinsc = getInscrSphRadius(i)
         rws = getWignerSeitzRadius(i)
!         volume = PI4*THIRD*(rws**3)
!         call setAtomVolWS(i,volume)
!         volume = PI4*THIRD*(rmt**3)
!         call setAtomVolMT(i,volume)
!         volume = PI4*THIRD*(rinsc**3)
!         call setAtomVolINSC(i,volume)
!         volume = getAtomicVPVolume(i)
!         call setAtomVolVP(i,volume)
!        -------------------------------------------------------------
!!!      call genRadialGrid( i, xstart, rmt, rinsc, rws, rend, ndivin )
!01252020call genRadialGrid( i, rmt, rinsc, rws, rend, ndivin, ndivout, nmult)
!        call genRadialGrid( i, rmt, rinsc, rend, ndivin = ndivin)
!        -------------------------------------------------------------
      endif
      rc = getAtomCoreRad(i)
      if (hin > TEN2m6 .or. rc < ONE) then
!        -------------------------------------------------------------
         call genRadialGrid(id=i, rmt=rmt, rinsc=rinsc, rend=rend,    &
                            ndivin=ndivin, xstep=hin)
!        -------------------------------------------------------------
      else if (isASAPotential()) then
!        -------------------------------------------------------------
         call genRadialGrid(id=i, rmt=rmt, rinsc=rinsc, rend=rend,    &
                            ndivin=ndivin)
!        -------------------------------------------------------------
      else
!        -------------------------------------------------------------
         call genRadialGrid(id=i, rmt=rmt, rinsc=rinsc, rend=rend,    &
                            ndivin=ndivin, rfix=rc)
!        -------------------------------------------------------------
      endif
      if (atom_print_level(i) >= 0) then
!        -------------------------------------------------------------
         call printRadialGrid(i)
!        -------------------------------------------------------------
      endif
      rmt_grid = getRadialGridRadius(i,MT=.true.)
      if (abs(rmt_grid-rmt) > TEN2m6) then
!        -------------------------------------------------------------
         call setMuffinTinRadius(i,rmt_grid)
!        -------------------------------------------------------------
         if (.not.isFullPotential()) then
!           ==========================================================
!           For Muffin-tin, ASA, or Muffin-tin-ASA calculations, since
!           potential outside rmt is 0, core radius is set to rmt
!           ----------------------------------------------------------
            call setAtomCoreRad(i,rmt_grid)
!           ----------------------------------------------------------
         endif
!        -------------------------------------------------------------
         call setSystemVolumeMT(i,rmt_grid)
!        -------------------------------------------------------------
         isRmtUpdated = .true.
      endif
      radius(i) = getOutscrSphRadius(i)
   enddo
   if ( isRmtUpdated ) then
!     ----------------------------------------------------------------
      call updateSystemVolume()
!     ----------------------------------------------------------------
   endif
   if (node_print_level >= 0) then
      call printSystemVolume()
   endif
!
!  ===================================================================
!  initialize and setup the Visual grid
!  -------------------------------------------------------------------
   if ( getDensityPrintFlag() >= 1 .or. getPotentialPrintFlag() >= 1) then
      if (.not.isUniform3DGridInitialized()) then
         call initUniform3DGrid(istop, node_print_level)
      endif
!     ----------------------------------------------------------------
      call fetchVisualDomainParameters(vna, vnb, vnc, vcell, vorigin)
!     ----------------------------------------------------------------
      call createUniform3DGrid('Visual',vna, vnb, vnc, vcell, cell_origin=vorigin)
!     ----------------------------------------------------------------
      call distributeUniformGrid('Visual')
      call insertAtomsInGrid('Visual', LocalNumAtoms, LocalAtomPosi,  &
                             getPointLocationFlag, radius)
!     ----------------------------------------------------------------
      if (node_print_level > 0) then
         call printUniform3DGrid('Visual')
      endif
   endif
   deallocate(radius)
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  setup the Lmax values.
!  ===================================================================
!  -------------------------------------------------------------------
   lmax_max=getMaxLmax()
!  -------------------------------------------------------------------
   allocate(lmax_pot(LocalNumAtoms))
   allocate(lmax_rho(LocalNumAtoms))
   allocate(lmax_kkr(LocalNumAtoms))
   allocate(lmax_phi(LocalNumAtoms))
   allocate(lmax_step(LocalNumAtoms))
   allocate(lmax_green(LocalNumAtoms))
   allocate(lmax_mad(LocalNumAtoms))
   allocate(lmax_tmp(LocalNumAtoms))
   lmax_kkr_max = 0
   lmax_rho_max = 0
   lmax_pot_max = 0
   do i=1,LocalNumAtoms
      lmax_kkr(i)   = getKKRLmax(i)
      lmax_phi(i)   = getPhiLmax(i)
      lmax_rho(i)   = getRhoLmax(i)
      lmax_pot(i)   = getPotLmax(i)
!
!     lmax_step(i)  = max(2*lmax_phi(i),getStepFuncLmax(i)) ! This change is
      lmax_step(i)  = getStepFuncLmax(i)                    ! made on 4/12/2015
!
      lmax_green(i) = min(2*lmax_phi(i),lmax_rho(i))
      lmax_mad(i) = max(lmax_rho(i),lmax_pot(i))
!new  lmax_max = max( lmax_max, lmax_step(i)+lmax_pot(i), lmax_rho(i), lmax_pot(i),&
      lmax_max = max( lmax_max, getTruncPotLmax(i), lmax_rho(i), lmax_pot(i), &
                      lmax_phi(i), lmax_kkr(i), lmax_green(i) )
      lmax_kkr_max  = max(lmax_kkr_max,lmax_kkr(i))
      lmax_rho_max  = max(lmax_rho_max,lmax_rho(i))
      lmax_pot_max  = max(lmax_pot_max,lmax_pot(i))
   enddo
!  ===================================================================
   MaxVal_Integer(1) = lmax_rho_max
   MaxVal_Integer(2) = lmax_pot_max
!  -------------------------------------------------------------------
#ifdef NVHPC
   call GlobalMax(lmax_pot_max)
   call GlobalMax(lmax_rho_max)
#else
print *,'Before MaxVal_Integer = ',MaxVal_Integer(1:2)
   call GlobalMax(MaxVal_Integer,2)
print *,'After  MaxVal_Integer = ',MaxVal_Integer(1:2)
!  -------------------------------------------------------------------
   lmax_rho_max = MaxVal_Integer(1)
   lmax_pot_max = MaxVal_Integer(2)
#endif
   lmax_gaunt = max(lmax_max,2*lmax_pot_max,2*lmax_rho_max)
!  ===================================================================
!  setup factors
!  -------------------------------------------------------------------
   call initSphericalHarmonics(2*lmax_gaunt)
!  -------------------------------------------------------------------
   call initGauntFactors(lmax_gaunt, istop, node_print_level)
!  -------------------------------------------------------------------
   if (IsoParamVINT) then
!     ----------------------------------------------------------------
      call initIsoparametricIntegration(lmax_max)
!     ----------------------------------------------------------------
   endif
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  initialize step function module
!  ===================================================================
   allocate( ngr(LocalNumAtoms), ngt(LocalNumAtoms) )
   do i=1,LocalNumAtoms
      ngr(i) = ngaussr
      ngt(i) = ngaussq
   enddo
!
   t1 = getTime()
!  -------------------------------------------------------------------
!  call initStepFunction(LocalNumAtoms,lmax_step,istop,node_print_level)
   call initStepFunction(LocalNumAtoms,lmax_max,lmax_step,ngr,ngt,istop,node_print_level)
!  -------------------------------------------------------------------
#ifdef TIMING
   if (node_print_level >= 0) then
      write(6,'(/,a,f10.5,/)')'Time:: initStepFunction: ',getTime()-t1
   endif
#endif
   do i=1,LocalNumAtoms
      lmax_tmp(i) = 2*max(lmax_rho(i), lmax_pot(i))
   enddo
   deallocate( ngr, ngt )
!
   do i=1,LocalNumAtoms
      if (atom_print_level(i) >= 0) then
!        -------------------------------------------------------------
         call printStepFunction(i)
!        -------------------------------------------------------------
         call testStepFunction(i)
!        -------------------------------------------------------------
      endif
   enddo
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  setup Madelung matrix
!  ===================================================================
   t2 = getTime()
!  -------------------------------------------------------------------
   call initMadelung(LocalNumAtoms,GlobalNumAtoms,GlobalIndex,        &
                     lmax_rho_max,lmax_pot_max,bravais,AtomPosition,  &
                     node_print_level)
!  -------------------------------------------------------------------
   if (node_print_level >= 0) then
      write(6,'(/,a,f10.5,/)')'Time:: initMadelung: ',getTime()-t2
   endif
!
   if (node_print_level >= 0) then
!     ----------------------------------------------------------------
      call printMadelungMatrix()
!     ----------------------------------------------------------------
   endif
!  -------------------------------------------------------------------
   call initSystemSymmetry( GlobalNumAtoms, LocalNumAtoms,            &
                            lmax_mad, lmax_step, atom_print_level )
!  -------------------------------------------------------------------
   call calSymmetryFlags()
!  -------------------------------------------------------------------
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  initialize potential module
!  -------------------------------------------------------------------
   call initPotential(LocalNumAtoms,lmax_pot, lmax_step,      &
                      n_spin_pola,n_spin_cant,istop,atom_print_level)
!  -------------------------------------------------------------------
!
   allocate(LocalNumValenceElectrons(LocalNumAtoms))
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
   if (isKKR() .or. isScreenKKR_LSMS() .or. isKKRCPA() .or. isKKRCPASRO()) then
!     ================================================================
!     initialize IBZ rotation matrix module
!     ----------------------------------------------------------------
      call initIBZRotation(isRelativisticValence(),getLatticeType(),  &
                           lmax_kkr_max,Symmetrize)
      call computeRotationMatrix(bravais,GlobalNumAtoms,AtomPosition,anum=AtomicNumber)
!     ----------------------------------------------------------------
      if( checkCrystalSymmetry(bravais,GlobalNumAtoms,AtomPosition,   &
                               anum=AtomicNumber) ) then
         if (node_print_level >= 0) then
            write(6,'(/,a,/)')'The crystal system has the point group symmetry!'
         endif
      else
         call ErrorHandler('main',                                    &
                           'The crystal system does not have the point group symmetry')
      endif
      if (node_print_level >= 0) then
!        -------------------------------------------------------------
         call printIBZRotationMatrix(Rot3D_Only=.true.)
!        -------------------------------------------------------------
      endif
!
!     if ( Symmetrize<0 .or. Symmetrize==1 ) then
!        NumRotations = getNumRotations()
!        -------------------------------------------------------------
!        call initSpecKInteg(lmax_kkr_max, NumRotations)
!        -------------------------------------------------------------
!     endif
!
!     ================================================================
!     Llody Module
!     ----------------------------------------------------------------
      call initKrein(LocalNumAtoms, n_spin_cant, n_spin_pola, lmax_kkr, &
                     getNumKs(), istop)
!     ----------------------------------------------------------------
   endif
!  ===================================================================
!  initialize exchange-correlation scheme, potential generation, total
!  energy calculation, and charge distribution book-keeping
!  -------------------------------------------------------------------
   call initExchCorrFunctional(n_spin_pola,excorr_name,node_print_level)
!  -------------------------------------------------------------------
   if (node_print_level >= 0) then
      if (isLDAFunctional()) then
         write(6,'(/,2x,a)')'========================================='
         write(6,'(2x,a)')  'Exchange-Correlation Functional Type: LDA'
         write(6,'(2x,a,/)')'========================================='
      else if (isGGAFunctional()) then
         write(6,'(/,2x,a)')'========================================='
         write(6,'(2x,a)')  'Exchange-Correlation Functional Type: GGA'
         write(6,'(2x,a,/)')'========================================='
      else if (isHybridFunctional()) then
         write(6,'(/,2x,a)')'============================================'
         write(6,'(2x,a)')  'Exchange-Correlation Functional Type: Hybrid'
         write(6,'(2x,a,/)')'============================================'
      else if (isMGGAFunctional()) then
         write(6,'(/,2x,a)')'=========================================='
         write(6,'(2x,a)')  'Exchange-Correlation Functional Type: MGGA'
         write(6,'(2x,a,/)')'=========================================='
      else if (isHartreeApproximation()) then
         write(6,'(/,2x,a)')'=========================================='
         write(6,'(2x,a)')  'This is Hartree approximation calculation.'
         write(6,'(2x,a,/)')'=========================================='
      else
         call ErrorHandler('main','Unknown exchange-correlation functional type')
      endif
   endif
!  ===================================================================
!
!  *******************************************************************
   t3 = getTime()
   if (isTestPotential()) then
!     ----------------------------------------------------------------
      call initTestPotential(LocalNumAtoms,n_spin_pola)
!     ----------------------------------------------------------------
      call readTestPotential(lmax_pot)
!     ----------------------------------------------------------------
      do i = 1,LocalNumAtoms
         jmax_pot = (lmax_pot(i)+1)*(lmax_pot(i)+2)/2
         val = ZERO
         do is = 1,n_spin_pola
            do jl=1,jmax_pot
!              -------------------------------------------------------
               pot_l => getTestPotential(i,is,jl)
!              -------------------------------------------------------
               call setPotential(i,1,is,jl,pot_l,1)
!              -------------------------------------------------------
            enddo
!           ----------------------------------------------------------
            val = val + getTestValenceNum(i,is)
!           ----------------------------------------------------------
         enddo
         LocalNumValenceElectrons(i) = val
      enddo
      do is = 1,n_spin_pola
         v0 = getTestV0(is)
         call setV0(is,v0)
      enddo
      Efermi=getTestPotEf()
!     ----------------------------------------------------------------
      call endTestPotential()
!     ----------------------------------------------------------------
   else
!     ================================================================
!     read potential data
!     ================================================================
!     ----------------------------------------------------------------
      call readPotential()
!     ----------------------------------------------------------------
      Efermi=getPotEf()
!
!     ================================================================
!     initialize core states module
!     ----------------------------------------------------------------
      call initCoreStates(LocalNumAtoms,ErBottom,n_spin_pola,         &
                          isNonRelativisticCore(),istop,node_print_level)
!                         fp_semicore=isFullPotential())
!     ----------------------------------------------------------------
!
!     ================================================================
!     read core states and density data of local atoms from file
!     ================================================================
      call readCoreStates()
!     ----------------------------------------------------------------
      do i = 1,LocalNumAtoms
         LocalNumValenceElectrons(i) = ZERO
         do ia = 1, getLocalNumSpecies(i)
            LocalNumValenceElectrons(i) = LocalNumValenceElectrons(i)  &
                 + getLocalSpeciesContent(i,ia)*getZval( getLocalAtomicNumber(i,ia) )
         enddo
      enddo
!
      if (isFrozenCore(fcf_name=FrozenCoreFileName,fcf_exist=FrozenCoreFileExist)) then
         if (FrozenCoreFileExist) then
!           ----------------------------------------------------------
            call readCoreDensity(FrozenCoreFileName)
!           ----------------------------------------------------------
         endif
      endif
#ifdef TIMING
      if (node_print_level >= 0) then
         write(6,'(/,a,f10.5,/)')'Time:: read potential and core states data: ',getTime()-t3
      endif
#endif
   endif
!  -------------------------------------------------------------------
   call syncAllPEs()
!  -------------------------------------------------------------------
   t_inp = t_inp + (getTime() - t3)
!  *******************************************************************
!
!  ===================================================================
   if (abs(ErTop) > TEN2m8 .and. getDOSrunID() == 0) then
      Efermi = ErTop
      if (node_print_level >= 0) then
         write(6,'(/,a,f12.8)')' Initial Fermi energy is set by the input:',Efermi
      endif
   else
      if (node_print_level >= 0) then
         write(6,'(/,a,f12.8)')' Initial Fermi energy read from the potential:',Efermi
      endif
   endif
!  ===================================================================
!
!  *******************************************************************
!
   t1 = getTime()
!  -------------------------------------------------------------------
   call initSpinRotation(LocalNumAtoms)
!  -------------------------------------------------------------------
   call initValenceDensity(LocalNumAtoms,LocalNumValenceElectrons,    &
                           lmax_rho,n_spin_pola,n_spin_cant,Efermi,   &
                           istop,atom_print_level,                    &
                           isGGA = isGGAFunctional().and.(.not.isDOSCalculationOnly))
!  -------------------------------------------------------------------
   call initGFMethod(LocalNumAtoms,GlobalIndex,LocalAtomPosi,         &
                     lmax_kkr,lmax_phi,lmax_pot,lmax_step,lmax_green, &
                     n_spin_pola,n_spin_cant,istop,atom_print_level,  &
                     isGGA = isGGAFunctional().and.(.not.isDOSCalculationOnly))
!  -------------------------------------------------------------------
   call initChargeDensity(LocalNumAtoms, GlobalIndex, lmax_rho,       &
                          n_spin_pola, n_spin_cant, atom_print_level, &
                          isGGA = isGGAFunctional().and.(.not.isDOSCalculationOnly))
!  -------------------------------------------------------------------
   call initChargeDistribution(LocalNumAtoms,GlobalNumAtoms,n_spin_pola)
!  -------------------------------------------------------------------
   call initPotentialGeneration(LocalNumAtoms,GlobalNumAtoms,lmax_pot,&
                                lmax_rho,n_spin_pola,istop,atom_print_level,&
                                isGGA = isGGAFunctional().and.(.not.isDOSCalculationOnly))
!  -------------------------------------------------------------------
   call initTotalEnergy(LocalNumAtoms,GlobalNumAtoms,getNumVacancies(),&
                        n_spin_pola,n_spin_cant,istop,atom_print_level,&
                        isGGA = isGGAFunctional().and.(.not.isDOSCalculationOnly))
!  -------------------------------------------------------------------
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  Setup the mixing
!  ===================================================================
   NumMix(1) = 0
   do i = 1,LocalNumAtoms
      NumMix(1) = NumMix(1) + getLocalNumSpecies(i)
   enddo
!  -------------------------------------------------------------------
   call initMixing( 1, NumMix, ArrayList )
!  -------------------------------------------------------------------
   call setupMixingScheme(LocalNumAtoms,n_spin_pola)
!  -------------------------------------------------------------------
   call initConstrainLM( LocalNumAtoms, n_spin_cant, n_spin_pola,     &
                         tstep, atom_print_level )
!  -------------------------------------------------------------------
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  If LDA correction is needed, call initLdaCorrection
!  ===================================================================
   if (isLdaCorrectionNeeded()) then
!     ----------------------------------------------------------------
      call initLdaCorrection(LocalNumAtoms,GlobalIndex,               &
                             getLocalAtomicNumber,getLocalNumSpecies)
!     ----------------------------------------------------------------
      call insertCorrectionOrbitals(getUJfile())
!     ----------------------------------------------------------------
   endif
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
   call initConvergenceCheck(LocalNumAtoms,n_spin_pola,n_spin_cant,   &
                             atom_print_level)
!  -------------------------------------------------------------------
   n = 0
   do id = 1, LocalNumAtoms
      n = n + getLocalNumSpecies(id)
   enddo
   allocate( rho_rms(n_spin_pola,n) )
   allocate( pot_rms(n_spin_pola,n) )
   allocate( evec_rms(LocalNumAtoms) )
   allocate( bcon_rms(LocalNumAtoms) )
   allocate( bcon_sd(3,LocalNumAtoms) )
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  Setup the force calculation
!  ===================================================================
   call initForce(LocalNumAtoms,istop,node_print_level)
!  ===================================================================
#ifdef TIMING
   if (node_print_level >= 0) then
      write(6,'(/,a,f10.5,/)')'Time:: initialize misc modules: ',getTime()-t1
   endif
#endif
!
!  ===================================================================
!  Start SCF iterations.
!  ===================================================================
   if (node_print_level >= 0) then
!     ----------------------------------------------------------------
      call printxml_scf_param()
!     ----------------------------------------------------------------
      write(6,'(/,80(''=''))')
      write(6,'(''Time:: Start-up   '',5x,'' :'',f12.5,''Sec'')') &
                    getTime()-t0
      write(6,'(80(''-''))')
   endif
!
   if (MyPE == 0) then
!     ----------------------------------------------------------------
      call initBookKeeping(info_path,getSystemID(),MyPE)
!     ----------------------------------------------------------------
   endif
!
   if ( movie > 0 ) then
!     ----------------------------------------------------------------
      call updateSystem('LIZ Size',getAtom2ProcInGroup)
!     ----------------------------------------------------------------
   endif
!
   niter = 0
   SD_LOOP: do itstep = 1,ntstep
!     ================================================================
!     reset the Initialization for calculating charge density on uniform grids
!     This needs to be done every time the atom positions are modified
!     ================================================================
!
      sdstep_new = 1
      rho_rms(:,:) = ZERO
      pot_rms(:,:) = ZERO
      evec_rms(:)  = ZERO
      bcon_rms(:)  = ZERO
      do i = 1,LocalNumAtoms
         bcon_sd(1:3,i) = getLocalConstrainField(i)
      enddo
      if (ntstep > 1 .and. node_print_level >= 0) then
         write(6,'(/,80(''*''))')
         write(6,'(/,a,i5,/)') 'SD_Loop :', itstep
      endif
!
      if (node_print_level >= 0) then
         call printAtomMomentInfo()
      endif
!
      n_potwrite = 0
      n_write = 0
      ScfConverged = .false.
      SCF_LOOP: do iscf = 1, nscf
         CurrentScfIteration = iscf
!
         if (isDOSCalculationOnly) then
!           ----------------------------------------------------------
            call calValenceDOS()
!           ----------------------------------------------------------
            t3 = getTime()
            call writeDOS(inputpath,getSystemID(),getDOSrunID())
            call writeSS_DOS(inputpath,getSystemID(),getDOSrunID())
            t_outp = t_outp + (getTime() - t3)
!           ----------------------------------------------------------
            exit SCF_LOOP
         endif
!
         if (iscf < 10) then
            write(anm,'(a,i1,a)')'scf',iscf,'pre_'
         else if (iscf < 100) then
            write(anm,'(a,i2,a)')'scf',iscf,'pre_'
         else if (iscf < 1000) then
            write(anm,'(a,i3,a)')'scf',iscf,'pre_'
         else
            write(anm,'(a,i4,a)')'scf',iscf,'pre_'
         endif
!
         if ( isFullPotential() ) then
            if ( getPotentialPrintFlag() >= 0 .and. node_print_level >= 1 ) then
               do id = 1,LocalNumAtoms
                  call printPot_L(id,aux_name=anm)
               enddo
            endif
         endif
!
         niter = niter+1
         if (node_print_level >= 0) then
            write(6,'(//,80(''*''))')
            write(6,'(28x,a,i3)')'SCF Iteration Number: ',iscf
            write(6,'(80(''*''),/)')
            call FlushFile(6)
         endif
!        -------------------------------------------------------------
         call resetSystemMovie()
!        -------------------------------------------------------------
!        =============================================================
!        sync all processors.
!        -------------------------------------------------------------
         call syncAllPEs()
!        -------------------------------------------------------------
!        =============================================================
!        calculate the core states.
!        =============================================================
         if (.not.isTestPotential() .and. .not.isFrozenCore(iter=iscf)) then
!           ----------------------------------------------------------
            call calCoreStates(evb)
!           ----------------------------------------------------------
            if (evb < ErBottom - TEN2m6) then
               ErBottom = evb
            endif
            do id = 1,LocalNumAtoms
               if (atom_print_level(id) >= 0) then
!                 ----------------------------------------------------
                  call printCoreStates(id)
!                 call printCoreDensity(id)
!                 ----------------------------------------------------
               endif
            enddo
         else if (isFrozenCore(iter=iscf)) then
            if (.not.isFrozenCore(iter=iscf-1) .and. .not.FrozenCoreFileExist) then
               t3 = getTime()
               call writeCoreDensity(FrozenCoreFileName)
               t_outp = t_outp + (getTime() - t3)
               FrozenCoreFileExist = .true.
            endif
            if (node_print_level >= 0) then
               write(6,'(//,80(''=''))')
               write(6,'(18x,a)')'Frozen core: core states are not recalculated'
               write(6,'(80(''=''),/)')
               call FlushFile(6)
            endif
         endif
!        =============================================================
!        At the beginning of each spin-dynamics time step, generate new 
!        evec direction and set constrain field to the potential.
!        =============================================================
         if ( n_spin_cant == 2 ) then
!           ----------------------------------------------------------
            call calConstrainLM(itstep,iscf)
!           ----------------------------------------------------------
         endif
!
         t1 = getTime()
!
!        =============================================================
!        call calValenceStates to calculation the valence density of
!        states, electron density, and Fermi energy
!        =============================================================
         t3 = getTime()
!        -------------------------------------------------------------
         call calValenceStates()
!        -------------------------------------------------------------
         if (node_print_level >= 0) then
            write(6,'(''Time:: calValenceStates :'',f12.5,''Sec'')')getTime()-t3
!           ----------------------------------------------------------
            call printValenceStates()
!           ----------------------------------------------------------
         endif
!
!        =============================================================
!        update the constrain field, moment direction, reset
!        the potential to the local direction.
!        =============================================================
         if ( n_spin_cant == 2 ) then
!           ----------------------------------------------------------
            call updateConstrainLM()
!           ----------------------------------------------------------
         endif
!        =============================================================
!
!        *************************************************************
!
!        =============================================================
!        Construct the total electron density (and moment density)
!        -------------------------------------------------------------
         call constructChargeDensity()
!        -------------------------------------------------------------
!
!        =============================================================
!
!        *************************************************************
!
!        =============================================================
!        update the charge distribution table.
!        -------------------------------------------------------------
         call updateChargeDistribution(getExchangeEnergy)
!        -------------------------------------------------------------
!        =============================================================
!
!        *************************************************************
!
!        =============================================================
!        Calculate the new DFT-LDA potential from the new density
!        =============================================================
#ifdef EPrint_MT
         if ( isFullPotential() ) then
!           ----------------------------------------------------------
            call computeNewPotential(isMT=.true.)
!           ----------------------------------------------------------
            call computeEnergyFunctional(isMT=.true.)
!           ----------------------------------------------------------
            if ( node_print_level >= 0 ) then
!              -------------------------------------------------------
               call printTotalEnergy(isMT=.true.)
!              -------------------------------------------------------
            endif
         endif
#endif
         t2 = getTime()
!        -------------------------------------------------------------
         call computeNewPotential()
!        -------------------------------------------------------------
         if (node_print_level >= 0) then
            write(6,'(/,a,f10.5,/)')'Time:: computeNewPotential: ',getTime()-t2
         endif
!
!        =============================================================
!
!        *************************************************************
!
!        =============================================================
!        calculate the DFT total energy.
!        -------------------------------------------------------------
         call computeEnergyFunctional()
!        -------------------------------------------------------------
         if ( node_print_level >= 0 ) then
!           ----------------------------------------------------------
            call printTotalEnergy()
!           ----------------------------------------------------------
         endif
!
!        =============================================================
!        Calculate the force...
!        =============================================================
         if ( isFullPotential() ) then
!           ----------------------------------------------------------
            call calForce()
!           ----------------------------------------------------------
            if (node_print_level >= 0) then
!              -------------------------------------------------------
               call printForce()
!              -------------------------------------------------------
            endif
         endif
!        =============================================================
!        check for convergence
!        -------------------------------------------------------------
         call checkConvergence( rho_rms, pot_rms,                     &
                                evec_rms, bcon_rms, getFermiEnergy(), &
                                getEnergyPerAtom(), itstep, iscf, max_rms, ScfConverged)
!        -------------------------------------------------------------
!
!        =============================================================
         call updateSystem('RMS Info',getAtom2ProcInGroup)
!        -------------------------------------------------------------
         call updateSystem('Energy Pressure',getAtom2ProcInGroup)
!        -------------------------------------------------------------
         if ( isFullPotential() ) then
!           ----------------------------------------------------------
            call updateSystem('Force Data',getAtom2ProcInGroup)
!           ----------------------------------------------------------
         endif
         if (n_spin_cant == 2) then
!           ----------------------------------------------------------
            call updateSystem('Exchange Field Direction',getAtom2ProcInGroup)
            call updateSystem('Moment Direction',getAtom2ProcInGroup)
            call updateSystem('Constrain Field',getAtom2ProcInGroup)
!           ----------------------------------------------------------
         endif
!
!        *************************************************************
!
!        =============================================================
!        setup the quantities for mixing.
!        =============================================================
         if ( .not. isFullPotential() ) then
!           ----------------------------------------------------------
            call setupMixRealArrayList( LocalNumAtoms, n_spin_pola,    &
                                        ArrayList, rho_rms, pot_rms )
!           ----------------------------------------------------------
            call mixValues(ArrayList)
!           ----------------------------------------------------------
            call updateMixRealValues( LocalNumAtoms, n_spin_pola,      &
                                      ArrayList )
!           ----------------------------------------------------------
         else
!           ----------------------------------------------------------
            call setupMixCmplxArrayList( LocalNumAtoms, n_spin_pola,   &
                                         ArrayList, rho_rms, pot_rms )
!           ----------------------------------------------------------
            if ( .not.( (isSphericalInputFile() .or. isChargeMixing()) .and. iscf==1) ) then
               call mixValues(ArrayList )
            endif
!           ----------------------------------------------------------
            call updateMixCmplxValues(LocalNumAtoms,n_spin_pola,ArrayList)
!           ----------------------------------------------------------
         endif
!
         if ( movie > 0 .and. MyPE == 0) then
            if (iscf == 1 .and. itstep == 1) then
!              -------------------------------------------------------
               call driverSystemMovie( .true., getEnergyPerAtom(), funit_sysmov, en_movie )
!              -------------------------------------------------------
            endif
            if ( n_write+1 == movie ) then
               call printSystemMovie(iscf,itstep,funit_sysmov,en_movie)
            endif
         endif
!
         if (n_spin_cant == 2) then
!           ----------------------------------------------------------
            call updateLocalExchangeFieldDir()
            call updateSystem('Exchange Field Direction',getAtom2ProcInGroup)
            call updateSystem('Moment Direction',getAtom2ProcInGroup)
            call updateSystem('Constrain Field',getAtom2ProcInGroup)
!           ----------------------------------------------------------
         endif
!        =============================================================
!
!        *************************************************************
!
!        =============================================================
         if ( isChargeMixing() ) then
!           ==========================================================
!           update the potential
!           ==========================================================
!           ----------------------------------------------------------
            call updatePotential(LocalNumAtoms,n_spin_pola)
!           ----------------------------------------------------------
!           ==========================================================
!           update the charge distribution table.
!           ==========================================================
!           ----------------------------------------------------------
            call updateChargeDistribution(getExchangeEnergy)
!           ----------------------------------------------------------
            call computeNewPotential()
!           ----------------------------------------------------------
         endif
!
!        =============================================================
!        update potentials and desities
!        =============================================================
!        -------------------------------------------------------------
         call updatePotential(LocalNumAtoms,n_spin_pola)
!        -------------------------------------------------------------
         call updateTotalDensity(setValenceVPCharge, setValenceVPMomentSize)
!        -------------------------------------------------------------
!
         Efermi = getFermiEnergy()
         call setPotEf(Efermi)
!        =============================================================
!
!        *************************************************************
!
!        =============================================================
!        write data to the book-keeping file
!        -------------------------------------------------------------
         if ( MyPE == 0 ) then
            keep_rms(1) = max(max_rms(1),max_rms(2))
            keep_rms(2) = max(max_rms(3),max_rms(4))
            keep_rms(3:4) = max_rms(5:6)
!           ----------------------------------------------------------
            call keep(sdstep_new,niter,keep_rms)
!           ----------------------------------------------------------
            sdstep_new = 0
         endif
#ifdef DEBUG
         write(6,*) "Main:: End SCF"
         call printAtomMomentInfo()
#endif
         t1 = getTime() - t1
         if ( node_print_level >= 0 ) then
            write(6,'(/,80(''=''))')
            write(6,'(''Time:: Iteration  '',i5,'' :'',f12.5,''Sec'')') &
                    iscf, t1
            write(6,'(''Time:: Cummulative'',5x,'' :'',f12.5,''Sec'')') &
                    getTime()-t0
            write(6,'(80(''=''))')
         endif
!        =============================================================
!
         t3 = getTime()
!        -------------------------------------------------------------
         call  printScfResults(GlobalNumAtoms,LocalNumAtoms,             &
                               node_print_level,atom_print_level,n_write,&
                               movie,iscf,nscf,ScfConverged)
!        -------------------------------------------------------------
         t_outp = t_outp + (getTime() - t3)
!
!        *************************************************************
!
!        =============================================================
!        output potential and electron density
!        =============================================================
         n_potwrite = n_potwrite + 1
         if ( potwrite > 0 .and. (n_potwrite==potwrite .or. iscf==nscf &
                                  .or. ScfConverged) ) then
            t3 = getTime()
!           ----------------------------------------------------------
            call writePotential()
!           ----------------------------------------------------------
            t_outp = t_outp + (getTime() - t3)
            n_potwrite = 0
         endif
!
         if (ScfConverged .or. nscf == 1) then
            rstatus = getKeyValue(def_id,'Calculate Superconducting Tc',calTc)
            if ( .not.isRelativisticValence() .and. calTc > 0 ) then
!              changed by xianglin because calPartialDOS has not been implemented for REL
!              -------------------------------------------------------
               call calPartialDOS(getFermiEnergy())
!              -------------------------------------------------------
            endif
            exit SCF_LOOP
         endif
!
      enddo SCF_LOOP
!
      do i = 1,LocalNumAtoms
         bcon_sd(1:3,i) = getLocalConstrainField(i)-bcon_sd(1:3,i)
         bcon_rms(i) = sqrt( bcon_sd(1,i)**2 + &
                             bcon_sd(2,i)**2 + &
                             bcon_sd(3,i)**2 )
      enddo
      max_rms(8) = maxval(bcon_rms)
      call GlobalMax(max_rms(8))
      if ( max_rms(8) < rmstol .and. max_rms(8)/=ZERO ) then
         if (node_print_level >= 0) then
            write(6,'(/,a)')' SD-Convergence is reached!!!'
            write(6,'(/,80(''=''))')
         endif
         exit SD_LOOP
      endif
   enddo SD_LOOP
!
   if ( MyPE==0 .and. movie > 0) then
      call driverSystemMovie( .false., getEnergyPerAtom(), funit_sysmov, en_movie )
   endif
!
   if ( isFullPotential() .and. node_print_level >= 0 .and. ScfConverged) then
!     ----------------------------------------------------------------
      call writeForceData(inputpath)
!     ----------------------------------------------------------------
   endif
!  -------------------------------------------------------------------
   call syncAllPEs()
!  -------------------------------------------------------------------
!
   deallocate(LocalEvec)
   deallocate(LocalNumValenceElectrons)
!
   if (n_spin_cant == 2) then
      t3 = getTime()
!     ----------------------------------------------------------------
      call writeMomentDirectionData()
!     ----------------------------------------------------------------
      t_outp = t_outp + (getTime() - t3)
   endif
!
   if ( isExchangeParamNeeded() .and. n_spin_cant == 2 ) then
      call printExchangeParam(trim(inputpath)//'OneSiteExchangeParam.dat', &
                              trim(inputpath)//'PairExchangeParam.dat')
   endif
!
   if ( isExchangeParamNeeded() .and. (isKKR() .or. isScreenKKR_LSMS() &
          .or. isKKRCPA() .or. isKKRCPASRO()) ) then
      if ( isScreenKKR_LSMS() ) then
         call setScfMethod("ScreenKKR")
      endif
      if ( Symmetrize/=0 ) then
         Symmetrize = 0
      endif
!     ----------------------------------------------------------------
      call endBZone()
!     ----------------------------------------------------------------
      if (isReadKmesh()) then
!        -------------------------------------------------------------
         call initBZone(getKmeshFileName(),istop,node_print_level)
!        -------------------------------------------------------------
      else if (NumKMeshs > 0) then
!        -------------------------------------------------------------
         call initBZone(NumKMeshs,kGenScheme,Kdiv,Symmetrize,bravais, &
                       GlobalNumAtoms,AtomPosition,AtomicNumber,istop,&
                       node_print_level)
!        -------------------------------------------------------------
      else
!        -------------------------------------------------------------
         call WarningHandler('main','No K mesh is initialized')
!        -------------------------------------------------------------
      endif
!
! The following lines of code were from version 2.0 and are commented out
! In order to calcuculate the exchange interaction, ExchangeInteractionModule
! needs to be modified
!     ----------------------------------------------------------------
!v2.0 call initExchangeInteraction( LocalNumAtoms, lmax_kkr, lmax_phi,    &
!v2.0                               lmax_pot, LocalAtomPosi, n_spin_pola, &
!v2.0                               n_spin_cant, getFermiEnergy(),        &
!v2.0                               istop, atom_print_level )
!     ----------------------------------------------------------------
!v2.0 call calExchgInteractions()
!     ----------------------------------------------------------------
!v2.0 call printExchange()
!     ----------------------------------------------------------------
!v2.0 call endExchangeInteraction()
!     ----------------------------------------------------------------
stop 'Under construction...'
   endif
!  ===================================================================
!
!  *******************************************************************
!
!  ===================================================================
!  clean up the allocated spaces.
!  ===================================================================
   nullify(AtomPosition,AtomicNumber)
   deallocate( GlobalIndex, LocalAtomPosi, atom_print_level )
   deallocate( lmax_kkr, lmax_phi, lmax_pot, lmax_rho, lmax_green, lmax_mad)
   deallocate( lmax_step, rho_rms, pot_rms, lmax_tmp )
!
!  -------------------------------------------------------------------
   call endInput()
!  -------------------------------------------------------------------
   if ( MyPE== 0) then
!     ----------------------------------------------------------------
      call endBookKeeping()
!     ----------------------------------------------------------------
   endif
   if (node_print_level >= 0) then
!     ----------------------------------------------------------------
      call printxml_scf_results()
!     ----------------------------------------------------------------
      write(6,'(/,80(''=''))')
      t3 = getTime()-t0
      t2 = t_inp + t_outp
      write(6,'(''Time:: Job total including IO :'',f12.5,''Sec'')') t3
      write(6,'(''       Job total excluding IO :'',f12.5,''Sec'')') t3 - t2
      write(6,'(80(''-''))')
   endif
!
   if (isKKR() .or. isScreenKKR_LSMS() .or. isKKRCPA()  .or. isKKRCPASRO()) then
!     ----------------------------------------------------------------
      call endBZone()
      call endIBZRotation()
!     ----------------------------------------------------------------
!     if ( Symmetrize==0 .or. Symmetrize==1 ) then
!        call endSpecKInteg()
!     endif
   endif
!
   if (.not.isTestPotential()) then
      call endCoreStates()
   endif
!
   if (node_print_level >= 0) then
      write(6,*) " Run Ending! "
      call FlushFile(6)
   endif
!
   if (isLdaCorrectionNeeded()) then
!     ----------------------------------------------------------------
      call endLdaCorrection()
!     ----------------------------------------------------------------
   endif
   call endConstrainLM()
   call endForce()
   call endConvergenceCheck()
   call endTotalEnergy()
   call endChargeDensity()
   call endChargeDistribution()
   call endMadelung()
   call endPotentialGeneration()
   call endExchCorrFunctional()
   call endValenceDensity()
   call endGFMethod()
   call endSpinRotation()
   call endPotential()
   call endStepFunction()
   call endRadialGrid()
   if ( IsoParamVINT ) then
      call endIsoparametricIntegration()
   endif
   if (isUniform3DGridInitialized()) then
      call endUniform3DGrid()
   endif
   call endKrein()
   call endSystemSymmetry()
   call endLattice()
   call endGauntFactors()
   call endSphericalHarmonics()
   call endSendRecvTmat()
   call endNeighbor()
   call endPotentialType()
   call endAtom()
   call endSystemVolume()
   call endAtom2Proc()
   call endParallelIO()
   call endProcMapping()
   if (isKKRCPA() .or. isEmbeddedCluster() .or. isKKRCPASRO()) then
!     ----------------------------------------------------------------
      call endMediumHost()
!     ----------------------------------------------------------------
   endif
   call endSystem()
   call endDataServiceCenter()
   call endCheckPoint()
   call endGroupComm()
   call endMPP()
!
!  ===================================================================
   if (node_print_level >= 0) then
!     ----------------------------------------------------------------
      call endXMLData()
!     ----------------------------------------------------------------
      call date_and_time(exec_date,exec_time)
      write(6,'(/,12a)')'Execution ends at ',                         &
           exec_time(1:2),':',exec_time(3:4),':',exec_time(5:6),', ', &
           exec_date(5:6),'-',exec_date(7:8),'-',exec_date(1:4)
      write(6,'(80(''-''))')
      write(6,'(a)')'End of a successful run......!'
   endif
!
   call endTimer()
   call endOutput()
!
end program mst2
